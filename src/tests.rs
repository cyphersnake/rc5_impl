use super::*;

#[test]
fn encode_a() {
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    let pt = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77];
    let ct = [0x2D, 0xDC, 0x14, 0x9B, 0xCF, 0x08, 0x8B, 0x9E];
    assert_eq!(ct.as_slice(), &pt.encode_rc5(key).unwrap());
}

#[test]
fn encode_b() {
    let key = [
        0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00, 0x95, 0x2C, 0x49, 0x10, 0x48, 0x81, 0xFF,
        0x48,
    ];
    let pt = [0xEA, 0x02, 0x47, 0x14, 0xAD, 0x5C, 0x4D, 0x84];
    let ct = [0x11, 0xE4, 0x3B, 0x86, 0xD2, 0x31, 0xEA, 0x64];
    assert_eq!(ct.as_slice(), &pt.encode_rc5(key).unwrap());
}

#[test]
fn decode_a() {
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    let pt = [0x96, 0x95, 0x0D, 0xDA, 0x65, 0x4A, 0x3D, 0x62];
    let ct = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77];
    assert_eq!(pt.as_slice(), &ct.decode_rc5(key).unwrap());
}

#[test]
fn decode_b() {
    let key = [
        0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00, 0x95, 0x2C, 0x49, 0x10, 0x48, 0x81, 0xFF,
        0x48,
    ];
    let pt = [0x63, 0x8B, 0x3A, 0x5E, 0xF7, 0x2B, 0x66, 0x3F];
    let ct = [0xEA, 0x02, 0x47, 0x14, 0xAD, 0x5C, 0x4D, 0x84];
    assert_eq!(pt.as_slice(), &ct.decode_rc5(key).unwrap());
}

#[test]
fn case8_12_4() {
    assert_eq!(
        &[0x00, 0x01]
            .encode_rc5_with_settings([0x00, 0x01, 0x02, 0x03], Rc5Settings::<u8>::new(12))
            .unwrap(),
        &[0x21, 0x2a],
    );
}

#[test]
fn wrong_input_case() {
    for len in [1, 3, 5, 7] {
        assert_eq!(
            vec![0x00; len]
                .as_slice()
                .encode_rc5_with_settings([0x00, 0x01, 0x02, 0x03], Rc5Settings::<u8>::new(12)),
            Err(Error::WrongInputSize),
            "for len {len}",
        );
    }
    for len in [1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15] {
        assert_eq!(
            vec![0x00; len]
                .as_slice()
                .encode_rc5_with_settings([0x00, 0x01, 0x02, 0x03], Rc5Settings::<u16>::new(12)),
            Err(Error::WrongInputSize),
            "for len {len}",
        );
    }
}

#[test]
fn case8_1_4() {
    assert_eq!(
        &[0x00, 0x01]
            .encode_rc5_with_settings([0x00, 0x01, 0x02, 0x03], Rc5Settings::<u8>::new(1))
            .unwrap(),
        &[123, 245],
    );
}

#[test]
fn case16_16_8() {
    assert_eq!(
        &[0x00, 0x01, 0x02, 0x03]
            .encode_rc5_with_settings(
                [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07],
                Rc5Settings::<u16>::new(16)
            )
            .unwrap(),
        &[0x23, 0xA8, 0xD7, 0x2E],
    );
}

#[test]
fn case32_20_16() {
    assert_eq!(
        &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,]
            .encode_rc5_with_settings(
                [
                    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
                    0x0D, 0x0E, 0x0F,
                ],
                Rc5Settings::<u32>::new(20)
            )
            .unwrap(),
        &[0x2A, 0x0E, 0xDC, 0x0E, 0x94, 0x31, 0xFF, 0x73,],
    );
}

#[test]
fn case64_24_24() {
    assert_eq!(
        &[
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
            0x0E, 0x0F,
        ]
        .encode_rc5_with_settings(
            [
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
                0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
            ],
            Rc5Settings::<u64>::new(24)
        )
        .unwrap(),
        &[
            0xA4, 0x67, 0x72, 0x82, 0x0E, 0xDB, 0xCE, 0x02, 0x35, 0xAB, 0xEA, 0x32, 0xAE, 0x71,
            0x78, 0xDA,
        ],
    );
}

#[test]
fn case128_28_32() {
    assert_eq!(
        &[
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
            0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
            0x1C, 0x1D, 0x1E, 0x1F,
        ]
        .encode_rc5_with_settings(
            [
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
                0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
                0x1C, 0x1D, 0x1E, 0x1F,
            ],
            Rc5Settings::<u128>::new(28)
        )
        .unwrap(),
        &[
            0xEC, 0xA5, 0x91, 0x09, 0x21, 0xA4, 0xF4, 0xCF, 0xDD, 0x7A, 0xD7, 0xAD, 0x20, 0xA1,
            0xFC, 0xBA, 0x06, 0x8E, 0xC7, 0xA7, 0xCD, 0x75, 0x2D, 0x68, 0xFE, 0x91, 0x4B, 0x7F,
            0xE1, 0x80, 0xB4, 0x40,
        ],
    );
}

#[cfg(feature = "secrecy")]
#[test]
fn secrecy_case8_1_4() {
    assert_eq!(
        &[0x00, 0x01]
            .encode_rc5_with_settings(
                secrecy::Secret::new([0x00, 0x01, 0x02, 0x03]),
                Rc5Settings::<u8>::new(1)
            )
            .unwrap(),
        &[123, 245],
    );
}
